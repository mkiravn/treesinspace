---
title: "Trees in Space"
output: html_notebook
---

According to classic branching brownian motion, we have particles which branch at a constant rate (1) and move according to independent random walks in x and y dimensions $x_t,y_t \sim N(0,t)$. However, we need to adjust the branch lengths of this process. With this constant rate, $T_k \sim \sum^k_{i=1}{exp(1)}=exp(k)$. In a coalescent tree, then $T_k \sim exp(^kC_2)$.

Let's illustrate this.

```{r}
devtools::load_all()
library(tidyverse)
library(ape)
library(sf)
library(MetBrewer)
library(ggrepel)
library(ggpubr)
library(ggtree)
library(moments)
devtools::load_all("~/slendr")
setup_env()
check_env()
```


```{r}
# let's generate a random tree with 100 tips
n <- 50
tr <- rtree(n)
#rcoal(n, br = "coalescent") %>% plot() # I also just discovered this function...
# and let's have a look at it
plot(tr)
```

Now, we can adjust the branch lengths to generate a coalescent-looking tree.

```{r}
# let's make an Ne which scales the rate of coalescence
Ne <- n
# edge_calculator takes the tree above with its topology, and sets branch lengths
tree <- edge_calculator(tr,
                        tree_mode = "coalescent", #stretches the edges so that T_n~exp(nC2)/2Ne
                        # if we had tree_mode = "brown", T_n~exp(1)
                        Ne=Ne) # (this is not needed if tree_mode="brown")
plot(tree) # now we see that the branch lengths are different and all the tips are in the present
nodelabels()
```

Now, I want to make these guys take a walk in space. So, I walk down the tree recursively, looking at each parent-child duo.
Given a per-generation dispersal distance $d$, for each edge of length $t$, I draw displacements in x and y: $\delta x_t,\delta y_t \sim N(0,td)$. The root of the tree is placed at the origin, and descendants are scattered from their parents according to this displacement.

```{r}
tree_sim <- move_nodes(tree,disp_dist = 1)
nodes <- tree_sim$nodes # the node locations and times are stored in nodes. 
# this is an sf object, which will allow us to do nice things downstream...
```

We can fit a Yule model to these trees, by the way.

```{r}
yule(rcoal(n, br = "coalescent")) 
yule(tree_sim)
yule(tr)
```

We might also want to visualise the nodes. 

```{r}
ggplot(nodes) + 
  geom_sf(aes(col=time)) + 
  scale_color_gradientn(colors=met.brewer("Hokusai1")) +
  theme_minimal()
```

Since most of the edges are short and recent, we see that the nodes are clustered. We can actually do better with the visualisation though, and show branches and identities as well. 

```{r}
links <- treesim_connect(tree_sim)[[1]]
```

```{r}
ggplot(nodes) + 
  scale_color_gradientn(colors=met.brewer("Hokusai1")) +
  geom_label_repel(aes(label=node_id,x=x,y=y))+
  geom_sf(data=links,aes(geometry=connection,col=parent_time)) +
  geom_sf(aes(col=time)) + 
  theme_minimal()
```

The root (51) is the oldest, and its descendants are scattered in clusters. The internal branches are much longer, both in terms of time and jump in space. We can try to verify whether this is brownian by looking at the distribution of displacement per generation in x and y. This info is held within `links`:

```{r}
# let's draw from a normal distribution to get the expected shape of the curve
normal <- data.frame(dsp=rnorm(50000,0,1))
# and now let's compare this to what happens in our tree
links %>%
  pivot_longer(cols = c("x_disp_pergen","y_disp_pergen"),
               names_to = "dim",
               values_to = "dsp") %>%
  ggplot(aes(x=dsp,col=dim))+
  geom_density()+
  geom_density(data=normal,
               aes(col="N(0,1)"),
               lty=2)+
  theme_classic()
```

Looks pretty good!

In this type of simulation, spatial similarity is very closely mirrored by genetic similarity. I can illustrate this by first performing a simple hierarchical clustering on the eucledian distance between points...

```{r}
pairs_sim <- find_ancestors(tree=tree_sim,data=tree_sim$nodes)
dmat_sim <- pairs_sim %>%
  mutate(distance=st_length(line)) %>%
  select(n1,n2,distance) %>%
  pivot_wider(names_from = n2,values_from = distance) %>%
  column_to_rownames("n1") %>% as.matrix() 
dmat_sim[is.na(dmat_sim)==TRUE] <- 0
clust_sim <- hclust(as.dist(dmat_sim))
```

And plotting this tree compared to the true phylogeny....

```{r}
p1 <- ggtree(tree_sim) 
p2 <- ggtree(clust_sim)

d1 <- p1$data %>% mutate(label=as.character(label))
d2 <- p2$data %>% mutate(label=as.character(label))

## reverse x-axis and 
## set offset to make the tree on the right-hand side of the first tree
d2$x <- (max(d2$x) - d2$x + max(d1$x) + 100)

pp <- p1 + geom_tree(data=d2) 

dd <- bind_rows(d1, d2) %>% 
  filter(!is.na(label))

pp + geom_line(aes(x, y, group=node,col=as.factor(node)), data=dd,alpha=0.5) 
```
It's clear that these two are quite similar.

### Simulating trees in slendr

Now, I want to simulate trees in slendR, and see how Brownian they look. I'll first set out some parameters, which include:
* the competition distance: in what radius and individual competes with its neighbours. This affects the fitness scaling of individuals (in crowded areas, fitness is scaled down).
* the mating distance: how far can an individual look for a mate? In theory, fi we want this to be as Brownian as possible, this should be small. When children are generated in slim, a parent is randomly chosen as the mother and children are dispersed from this parent (we could change this also). If the mating distance is large, this might result in a surprisingly long edge, since a child may be dispersed very far from one of its parents (the one recorded in a particular tree). If this is too small, however, slim might crash because it will sometimes be unable to find a mate for an individual.
* the dispersal function: determines how a child is thrown away from its mother. We currently have:
  * Uniform: choose an angle and a distance from the uniform distribution
  * Cauchy: choose an angle from a uniform distribution and a distance from a cauchy
  * Exponential: choose an angle from a uniform distribution and a distance from an exponential distribution
  * Normal: choose an angle from a uniform distribution and a distance from a normal distribution (mean 0, $\sigma^2$ equal to dispersal distance). *Note: this actually results in a Rayleigh distribution of distances from the mother!*
  * Brownian: draw distances in x and y independently from noormal distributions of mean 0, $\sigma^2$ dispersal distance.

```{r}
# defining parameters
Ns <- n
mat_dists <- c(20,50,Ns * 4) # mate distance
comp_dists <- c(0,10,50,Ns * 4) # competition distance
disp_dists <- 1 # mean dispersal distance
disp_funs <- c("brownian","normal","cauchy")
reps <- c(1:5)
ngens <- Ns * 4 # expected time to coalescence

# let's also make a parameter table
pars <- expand.grid(N=Ns,
                    mat_dist=mat_dists,
                    comp_dist=comp_dists,
                    disp_fun=disp_funs,
                    disp_dist=disp_dists,
                    rep=reps,
                    ngen=ngens)
```

Now, I run a series of simulations with these parameters. 

```{r, warning=FALSE}
# defining a region
map <- world(
  # let's make this very large so that we avoid edge effects
  xrange = c(-ngens*4, ngens*4), # min-max longitude
  yrange = c(-ngens*4, ngens*4), # min-max latitude
  landscape = "blank"
)

# running the model
trees <- c()
trees_us <- c()
conns <- c()
i <- 1

for (row in c(1:dim(pars)[1])){

  # define a population
  pop <- population("POP",
                    time = 1,
                    N = pars[row,"N"],
                    center = c(0,0),
                    radius = ngens,
                    map = map,
                    mate_dist = pars[row,"mat_dist"],
                    competition_dist = pars[row,"comp_dist"],
                    dispersal_fun = as.character(pars[row,"disp_fun"]),
                    dispersal_dist = pars[row,"disp_dist"])

  # compile and run the model
  model <- compile(
    populations = pop,
    generation_time = 1,
    sim_length = ngens, # a forward in time model in slendr needs length of the sim
    resolution = 1, # resolution in "distance units per pixel"
    # how can we control this distribution?
    path = "~/Desktop/test-model",
    overwrite = TRUE
  )

  # let's sample 10 individuals in the "present"
  samples <- sampling(model, times = ngens, list(pop, n/2))

  # simulate
  slim(
    model, sampling = samples,
    sequence_length = 1,
    recombination_rate = 0, # simulate only a single locus
    method = "batch", # change to "gui" to execute the model in SLiMgui
    random_seed = 5*i,
    verbose = FALSE,
    retainall = TRUE,
    burnin = 0,
  )

  # extract trees
  ts <- ts_load(model, simplify = TRUE) %>%
    ts_recapitate(Ne = pars[row,"N"],
                  recombination_rate = 0) %>%
    ts_simplify() %>%
    ts_mutate(mutation_rate = 1e-4)
  
  # extract full genealogies trees
  tsu <- ts_load(model, simplify = FALSE) 

  # collect trees
  trees <- c(trees,ts)
  trees_us <- c(trees_us,tsu)

  #print(paste("Simulation number:",i))
  i <- i+1
}

# getting out the tree objects
trees_phylo <- lapply(trees, ts_phylo, i=1, quiet=TRUE) # convert
class(trees_phylo) <-  "multiPhylo" # convert list

tree_data <- data.frame()

# merge all the spatial tree data into a dataframe to plot
for (row in c(1:dim(pars)[1])){

  tree <- trees_phylo[[row]]

  tree_data_i <- tree %>% ts_data() %>% rowwise() %>% mutate(N=pars[row,"N"],
                                               fun=pars[row,"disp_fun"],
                                               rep=as.factor(pars[row,"rep"]),
                                               mat_dist=pars[row,"mat_dist"],
                                               comp_dist=pars[row,"comp_dist"],
                                               disp_dist=pars[row,"disp_dist"],
                                               sim=as.factor(row),
                                               x=unlist(location)[1],
                                               y=unlist(location)[2]) %>% ungroup()

  tree_data <- rbind(tree_data,tree_data_i)
  #print(paste("Converting tree no",row))
}
```

```{r}
tree_data <- tree_data %>% 
  group_by(sim) %>% 
  mutate(timeoriginal=time,time=timeoriginal-min(timeoriginal)) # adjust so that time starts at 0 (adjusting for recapitated trees)
# join dataframes
tree_sim_data <- tree_sim$nodes %>% mutate(simtype="tree")
tree_data_sims <- tree_data %>%
  mutate(simtype="slendr") %>% 
  bind_rows(tree_sim_data)
```


```{r}
tree_data_sims %>% ggplot()+
  geom_sf(aes(col=fun,fill=fun))+
  facet_grid(cols=vars(comp_dist),rows=vars(mat_dist), labeller = label_both)+
  theme_minimal()
```

If we have a competition distance of 0 (first column), the population tends to move like a slug because there is no limit on population density, which is arguably no good. Mating distance-wise, a higher mating distance also results in more fragmentation. In theory we should prefer a smaller mating distance. Why? We mentioned this earlier: in slendr, every time we make a child, we displace it by randomly picking one parent to be the mother and dispersing it from there. If this mate is far away (mating distance >> dispersal distance), we will sometimes make huge jumps, which would disturb the dispersal spectrum. 

There's an important point to think about here: *we cannot look at where the descendants are to when we simulate compared to the tree method to decide how brownian the process is*! With the tree method, we are effectively picking an ancestor, and looking at the tree with n descendants. They will be clustered. This is different to the slendr method, where we are sampling n tips randomly (scattered thorughout the landscape), and tracing back to a common ancestor! We can think of the tree model as more allele-centric: if the root had a new (neutral) mutation, carriers of this mutation are expected to be clustered! To get round this, we should be randomly picking a node at the start of the simulation and looking at the tree of its descendants. 

But, this also means for us that eyeballing the spread of individuals won't help. We need to look at the branch-wise dynamics. 

We can also directly look at the steps between parent and offspring. Fortunately, I've saved the location of everyone in the tree in `trees_us`! Now, I can extract the connections between the nodes. 

```{r}
conns <- lapply(trees_us,ts_connect)
```

Let's plot one of these, and verify that it corresponds to the simplified tree. 

```{r}
p_uns <- conns[[1]][[1]] %>%
  as.data.frame() %>%
  ggplot() +
  geom_sf(aes(geometry=connection,col=parent_time),alpha=0.2) +
  geom_sf(aes(geometry=parent_location,col=parent_time,shape="unsimplified"),alpha=0.5) +
  scale_color_gradientn(colors=met.brewer("Hokusai1"))

first_tree <- tree_data_sims %>% filter(sim==1) 

p_uns +
  geom_sf(data=first_tree ,aes(geometry=location,col=timeoriginal,shape="simplified")) +
  scale_color_gradientn(colors=met.brewer("Hokusai1")) +
  theme_minimal()
```

And again let's check with the edges connecting two tips.

```{r}
walk <- ts_ancestors(ts=trees_us[[1]],x = c(1,2)) %>% mutate(simple="no") %>% 
  rbind(mutate(ts_ancestors(ts=trees[[1]],x = c(1,2)),simple="yes"))

walk %>% ggplot(aes(col=parent_time,lty=simple,alpha=simple))+geom_sf(aes(geometry=connection)) +
  scale_color_gradientn(colors=met.brewer("Hokusai1")) +
  theme_minimal()
```
Let's look at per-generation dispersal:

```{r}
ds <- data.frame()
for (sim in c(1:dim(pars)[1])){
  d <- conns[[sim]][[1]] %>% as.data.frame() %>% select(x_disp,y_disp) %>% cbind(pars[sim,])
  ds <- rbind(ds,d)
}

ds %>% ggplot(aes(x=x_disp,col=disp_fun)) +
  geom_density(alpha=0.5) +
  facet_grid(cols=vars(comp_dist),rows=vars(mat_dist), labeller = label_both) +
  lims(x=c(-5,5)) +
  geom_density(data=normal,
               aes(col="N(0,1)",x=dsp),
               lty=2)+theme_minimal()

```
Let's look at the kurtosis and some moments. 

```{r}
dsm <- ds %>% 
  group_by(mat_dist,comp_dist,disp_fun) %>%
  summarise(kurtosis=kurtosis(x_disp),variance=var(x_disp)) %>%
  pivot_longer(cols=c("kurtosis","variance"),names_to = "statistic",values_to="value")
dsm %>%
  ggplot(aes(x=comp_dist,y=value,col=as.factor(mat_dist))) +
  geom_point() +
  geom_line() +
  facet_grid(rows=vars(statistic),cols=vars(disp_fun),scales="free_y")
```
And let's look at this over time. 

```{r}
dsmt <- ds %>% mutate(timegroup=cut(time,breaks = 4)) %>%
  group_by(mat_dist,comp_dist,disp_fun,timegroup) %>%
  summarise(kurtosis=kurtosis(x_disp),variance=var(x_disp)) %>%
  pivot_longer(cols=c("kurtosis","variance"),names_to = "statistic",values_to="value")

dsmt %>%
  ggplot(aes(x=comp_dist,y=value,col=as.factor(mat_dist),lty=timegroup)) +
  geom_point() +
  geom_line() +
  facet_grid(rows=vars(statistic),cols=vars(disp_fun),scales="free_y") +
```


### How good are we at finding ancestors?

```{r}
ancs <- find_ancestors(tree=tree_sim,data=nodes)

p1 <- ancs %>% filter(MRCA==n+1|MRCA==91) %>% ggplot(aes(col=as.factor(MRCA))) +
  geom_sf(aes(geometry=MRCA_location,shape="true location")) +
  geom_sf(aes(geometry=midpoint,shape="estimated"),alpha=0.1) +
  geom_sf(aes(geometry=midtomrca,lty="error"),alpha=0.1)

p2 <- ancs %>% ggplot(aes(x=MRCA_time,y=error)) +
  geom_jitter(alpha=0.5,size=0.5,aes(col=as.factor(MRCA))) +
  geom_smooth(aes(group=MRCA_time))

ggarrange(p1,p2,common.legend = TRUE)
```

Since in the tree simulations descendants of the first node are highly clustered, we're very good at estimating the true location of recent ancestors, and really bad at estimating locations of distant ancestors. This should be different in the slendr simulations, though. 

```{r}
ancs <- find_ancestors(tree=ts_phylo(trees[[1]],i=1),data=filter(tree_data_sims,sim==1))

p1 <- ancs %>% filter(MRCA==n+1|MRCA==91) %>% ggplot(aes(col=as.factor(MRCA))) +
  geom_sf(aes(geometry=MRCA_location,shape="true location")) +
  geom_sf(aes(geometry=midpoint,shape="estimated"),alpha=0.1) +
  geom_sf(aes(geometry=midtomrca,lty="error"),alpha=0.1)

p2 <- ancs %>% ggplot(aes(x=MRCA_time,y=error)) +
  geom_jitter(alpha=0.5,size=0.5,aes(col=as.factor(MRCA))) 

ggarrange(p1,p2,common.legend = TRUE)
```
Here, we're just ok at guessing where ancestors were, but not great. I would not really suggest running the cells below, they take a really long time. 

```{r,eval=FALSE}
ancs_all <- data.frame()
small_pars <- pars %>% filter(rep<3)
for (i in c(1:dim(small_pars)[1])){
  ancs_i <- find_ancestors(tree=trees_phylo[[i]],data=filter(tree_data_sims,sim==i)) %>% mutate(sim=i)
  ancs_all <- rbind(ancs_all,ancs_i)
}
```

Now we can explore this a bit more systematically.

```{r}
ancs_all <- ancs_all %>% left_join(mutate(rownames_to_column(pars,"sim"),sim=as.integer(sim)),by="sim")
ancs_all %>% ggplot(aes(x=MRCA_time,y=error,col=as.factor(disp_fun))) +
  geom_jitter(alpha=0.5,size=0.5) +
  facet_grid(cols=vars(comp_dist),rows=vars(mat_dist), labeller = label_both)
```
It's kind of simple: the less a population spreads, the less wrong we are. With no particular relationship to the time of the MRCA. 
